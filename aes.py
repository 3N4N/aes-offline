# -*- coding: utf-8 -*-
"""BitVector Demo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18MOtTMOl78t08PSpHkEQBQ7rmFk9Z8l6

Install The BitVector Library
"""
#pip install BitVector


"""Tables"""

from BitVector import *
import time

Sbox = (
    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16,
)

InvSbox = (
    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D,
)

Mixer = [
    [BitVector(hexstring="02"), BitVector(hexstring="03"), BitVector(hexstring="01"), BitVector(hexstring="01")],
    [BitVector(hexstring="01"), BitVector(hexstring="02"), BitVector(hexstring="03"), BitVector(hexstring="01")],
    [BitVector(hexstring="01"), BitVector(hexstring="01"), BitVector(hexstring="02"), BitVector(hexstring="03")],
    [BitVector(hexstring="03"), BitVector(hexstring="01"), BitVector(hexstring="01"), BitVector(hexstring="02")]
]

InvMixer = [
    [BitVector(hexstring="0E"), BitVector(hexstring="0B"), BitVector(hexstring="0D"), BitVector(hexstring="09")],
    [BitVector(hexstring="09"), BitVector(hexstring="0E"), BitVector(hexstring="0B"), BitVector(hexstring="0D")],
    [BitVector(hexstring="0D"), BitVector(hexstring="09"), BitVector(hexstring="0E"), BitVector(hexstring="0B")],
    [BitVector(hexstring="0B"), BitVector(hexstring="0D"), BitVector(hexstring="09"), BitVector(hexstring="0E")]
]

# b = BitVector(hexstring="4E")
# int_val = b.intValue()
# s = Sbox[int_val]
# s = BitVector(intVal=s, size=8)
# print(s.get_bitvector_in_hex())

# AES_modulus = BitVector(bitstring='100011011')

# bv1 = BitVector(hexstring="02")
# bv2 = BitVector(hexstring="63")
# bv3 = bv1.gf_multiply_modular(bv2, AES_modulus, 8)
# print(bv3)





def keygen(key):
    """
    Returns hex string of 16 characters ascii key.
    """
    key_hex = key.encode('utf-8').hex()

    # pad the key with 0x0 to be 16-byte long.
    if len(key_hex) < 32:
        key_hex = key_hex.ljust(32, '0')
    # trim the key to be 16-byte long.
    elif len(key_hex) > 32:
        key_hex = key_hex[:32]
    return key_hex

def pad(m):
    """
    Pads message with PKCS#5 padding so the length is a multiple of 16.
    """
    padlen = 16 - (len(m) // 2) % 16
    return m + ("{:02x}".format(padlen)) * (padlen)

def unpad(ct):
    """
    Unpads cipher with PKCS#5 padding.
    """
    padlen = int(ct[-2] + ct[-1], 16)
    return ct[:-(padlen * 2)]

def padtext(text):
    """
    Pads message with spaces so the length is a multiple of 16.
    """
    if len(text) % 16 != 0:
        return text.ljust((len(text) // 16 + 1) * 16, ' ')
    return text


def bytes_to_matrix(text):
    """
    Returns a 2d matrix with 4 columns from text.
    """
    mat = []
    for i in range(0, len(text), 8):
        li = []
        for j in range(0, 8, 2):
            li.append(text[i+j:i+j+2])
        li = [int(_, 16) for _ in li]
        mat.append(li)
    return mat


def transpose_matrix(mat):
    """
    Transposes a square matrix.

    MUST be a square matrix. Cannot guarantee safe execution if a non-square
    matrix is given as input.
    """
    return list(map(list, zip(*mat)))


def print_Xx4(key_mat):
    """
    Prints a 2d matrix which has 4 columns.
    """
    for i in range(len(key_mat) // 4):
        print([hex(x) for x in key_mat[i * 4]],
              [hex(x) for x in key_mat[i * 4 + 1]],
              [hex(x) for x in key_mat[i * 4 + 2]],
              [hex(x) for x in key_mat[i * 4 + 3]])
    # print([list(map(hex,x)) for x in key_mat])


def round_key_gen(key):
    """
    Generates the round keys for rounds of AES encryption and decryption.
    """

    key_mat = bytes_to_matrix(key)
    n_itr = (len(key_mat) * len(key_mat[0])) / 4
    n_rnd = 10

    rcon = [0, 1]
    for _ in range(n_rnd):
        rcon.append(rcon[-1] * 2)
        if rcon[-1] > 0x80:
            rcon[-1] ^= 0x11b


    for i in range(1, n_rnd + 1):
        root = list(key_mat[-1])
        # print([hex(x) for x in root])
        g_root = root

        g_root.append(g_root.pop(0))
        g_root = [Sbox[_] for _ in root]
        g_root[0] ^= rcon[i]
        # print([hex(x) for x in g_root])
        key_mat.append([key_mat[(i - 1) * 4][j] ^ g_root[j] for j in range(4)])
        key_mat.append([key_mat[-1][j] ^ key_mat[(i - 1) * 4 + 1][j] for j in range(4)])
        key_mat.append([key_mat[-1][j] ^ key_mat[(i - 1) * 4 + 2][j] for j in range(4)])
        key_mat.append([key_mat[-1][j] ^ key_mat[(i - 1) * 4 + 3][j] for j in range(4)])

    return key_mat

def schedule_keys(key):
    key = keygen(key)
    rnd_keys = round_key_gen(key)
    return rnd_keys


def add_rnd_key(t, k):
    for i in range(4):
        for j in range(4):
            t[i][j] ^= k[i][j]


def sub_bytes(t):
    for i in range(4):
        for j in range(4):
            t[i][j] = Sbox[t[i][j]]

def inv_sub_bytes(s):
    for i in range(4):
        for j in range(4):
            s[i][j] = InvSbox[s[i][j]]


def shift_rows(t):
    t[1][0], t[1][1], t[1][2], t[1][3] = t[1][1], t[1][2], t[1][3], t[1][0]
    t[2][0], t[2][1], t[2][2], t[2][3] = t[2][2], t[2][3], t[2][0], t[2][1]
    t[3][0], t[3][1], t[3][2], t[3][3] = t[3][3], t[3][0], t[3][1], t[3][2]

def inv_shift_rows(t):
    t[1][0], t[1][1], t[1][2], t[1][3] = t[1][3], t[1][0], t[1][1], t[1][2]
    t[2][0], t[2][1], t[2][2], t[2][3] = t[2][2], t[2][3], t[2][0], t[2][1]
    t[3][0], t[3][1], t[3][2], t[3][3] = t[3][1], t[3][2], t[3][3], t[3][0]


AES_modulus = BitVector(bitstring='100011011')

def mix_cols(t):
    _t = []
    for i in range(4):
        _t.append([0,0,0,0])
    for i in range(4):
        for j in range(4):
            for k in range(4):
                bv_t = BitVector(intVal=t[k][j], size=8)
                bv = bv_t.gf_multiply_modular(Mixer[i][k], AES_modulus, 8)
                _t[i][j] ^= bv.intValue()
    for i in range(4):
        for j in range(4):
            t[i][j] = _t[i][j]

def inv_mix_cols(t):
    _t = []
    for i in range(4):
        _t.append([0,0,0,0])
    for i in range(4):
        for j in range(4):
            for k in range(4):
                bv_t = BitVector(intVal=t[k][j], size=8)
                bv = bv_t.gf_multiply_modular(InvMixer[i][k], AES_modulus, 8)
                _t[i][j] ^= bv.intValue()
    for i in range(4):
        for j in range(4):
            t[i][j] = _t[i][j]


def split_blocks(text, block_size):
    return [text[i:i+block_size] for i in range(0, len(text), block_size)]


def encrypt_block(n_rnd, key_mat, plaintext):
    """
    Encrypts a textblock of 16 bytes.
    """
    txt_mat = bytes_to_matrix(plaintext)
    txt_mat = transpose_matrix(txt_mat)

    rnd_key = []
    rnd_key.append(key_mat[0])
    rnd_key.append(key_mat[1])
    rnd_key.append(key_mat[2])
    rnd_key.append(key_mat[3])
    rnd_key = transpose_matrix(rnd_key)
    add_rnd_key(txt_mat, rnd_key)

    for i in range(1, n_rnd):
        sub_bytes(txt_mat)
        shift_rows(txt_mat)
        mix_cols(txt_mat)
        rnd_key = []
        rnd_key.append(key_mat[i * 4])
        rnd_key.append(key_mat[i * 4 + 1])
        rnd_key.append(key_mat[i * 4 + 2])
        rnd_key.append(key_mat[i * 4 + 3])
        rnd_key = transpose_matrix(rnd_key)
        add_rnd_key(txt_mat, rnd_key)

    sub_bytes(txt_mat)
    shift_rows(txt_mat)
    rnd_key = []
    rnd_key.append(key_mat[n_rnd * 4])
    rnd_key.append(key_mat[n_rnd * 4 + 1])
    rnd_key.append(key_mat[n_rnd * 4 + 2])
    rnd_key.append(key_mat[n_rnd * 4 + 3])
    rnd_key = transpose_matrix(rnd_key)
    add_rnd_key(txt_mat, rnd_key)

    # print_Xx4(txt_mat)

    txt_mat = transpose_matrix(txt_mat)
    ciphertext = ''
    for i in range(len(txt_mat)):
        for j in range(len(txt_mat[i])):
            ciphertext += "{:02x}".format(txt_mat[i][j])
    return ciphertext


def decrypt_block(n_rnd, key_mat, ciphertext):
    """
    Decrypts a textblock of 16 bytes.
    """
    txt_mat = bytes_to_matrix(ciphertext)
    txt_mat = transpose_matrix(txt_mat)

    rnd_key = []
    rnd_key.append(key_mat[n_rnd * 4])
    rnd_key.append(key_mat[n_rnd * 4 + 1])
    rnd_key.append(key_mat[n_rnd * 4 + 2])
    rnd_key.append(key_mat[n_rnd * 4 + 3])
    rnd_key = transpose_matrix(rnd_key)
    add_rnd_key(txt_mat, rnd_key)
    inv_shift_rows(txt_mat)
    inv_sub_bytes(txt_mat)

    for i in range(n_rnd -1, 0, -1):
        rnd_key = []
        rnd_key.append(key_mat[i * 4])
        rnd_key.append(key_mat[i * 4 + 1])
        rnd_key.append(key_mat[i * 4 + 2])
        rnd_key.append(key_mat[i * 4 + 3])
        rnd_key = transpose_matrix(rnd_key)
        add_rnd_key(txt_mat, rnd_key)
        inv_mix_cols(txt_mat)
        inv_shift_rows(txt_mat)
        inv_sub_bytes(txt_mat)

    rnd_key = []
    rnd_key.append(key_mat[0])
    rnd_key.append(key_mat[1])
    rnd_key.append(key_mat[2])
    rnd_key.append(key_mat[3])
    rnd_key = transpose_matrix(rnd_key)
    add_rnd_key(txt_mat, rnd_key)

    # print_Xx4(txt_mat)

    txt_mat = transpose_matrix(txt_mat)
    plaintext = ''
    for i in range(len(txt_mat)):
        for j in range(len(txt_mat[i])):
            plaintext += "{:02x}".format(txt_mat[i][j])
    return plaintext


def encrypt(key, plaintext):
    """
    Encrypts plaintext of hexstring.
    """
    rnd_keys = schedule_keys(key)
    plaintext = pad(plaintext)
    ciphertext = ''
    for text_block in split_blocks(plaintext, 32):
        # text_block = text_block.encode('utf-8').hex()
        cipher_block = encrypt_block(10, rnd_keys, text_block)
        ciphertext += cipher_block
    return ciphertext


def decrypt(key, ciphertext):
    """
    Decrypts plaintext of hexstring.
    """
    rnd_keys = schedule_keys(key)
    plaintext = ''
    for cipher_block in split_blocks(ciphertext, 32):
        text_block = decrypt_block(10, rnd_keys, cipher_block)
        plaintext += text_block
    plaintext = unpad(plaintext)
    return plaintext


# key = 'Thats my Kung Fu DU'
key = 'BUET CSE16 Batch'
print('Key:')
print(key, '[ASCII]')
print(key.encode('utf-8').hex(), '[HEX]\n')

st = time.time()
rnd_keys = schedule_keys(key)
t_sch = time.time() - st

# plaintext = 'Two One Nine Two'
plaintext = 'WillGraduateSoon'
print('Plain Text:')
print(plaintext, '[ASCII]')
print(plaintext.encode('utf-8').hex(), '[HEX]\n')

st = time.time()
ciphertext = encrypt(key, plaintext.encode('utf-8').hex())
print('Cipher Text:')
print(ciphertext, '[HEX]\n')
t_enc = time.time() - st

st = time.time()
deciphertext = decrypt(key, ciphertext)
print('Deciphered Text:')
print(deciphertext, '[HEX]')
print(bytes.fromhex(deciphertext).decode('utf-8'), '[ASCII]\n')
t_dec = time.time() - st

print('Scheduling time:', t_sch)
print('Encryption time:', t_enc)
print('Decryption time:', t_dec)
print()

key = 'Thats my Kung Fu DU'
# key = 'Decrypt Task Six'

def encrypt_file(infile_name, outfile_name):
    ifile = open(infile_name, 'rb')
    ofile = open(outfile_name, 'wb')
    while True:
        data = ifile.read(1024*1024)
        if not data:
            break
        plaintext = data.hex()
        ciphertext = encrypt(key, plaintext)
        ofile.write(ciphertext.encode())
    ifile.close()
    ofile.close()

def decrypt_file(infile_name, outfile_name):
    ifile = open(infile_name, 'rb')
    ofile = open(outfile_name, 'wb')
    while True:
        data = ifile.read(1024*1024)
        if not data:
            break
        ciphertext = data
        ciphertext = data.decode('utf-8')
        ciphertext = ciphertext.replace('\n', '')
        deciphertext = decrypt(key, ciphertext)
        deciphertext = bytes.fromhex(deciphertext)
        ofile.write(deciphertext)
    ifile.close()
    ofile.close()

fn_plaintxt = "plain.txt"
fn_ciphertxt = "cipher.txt"
fn_deciphertxt = "decipher.txt"
print("Encrypting file...")
encrypt_file(fn_plaintxt, fn_ciphertxt)
print("Finished.")
print("Decrypting file...")
decrypt_file(fn_ciphertxt, fn_deciphertxt)
print("Finished.\n")

fn_plainimg = "plain.jpg"
fn_cipherimg = "cipher.jpg"
fn_decipherimg = "decipher.jpg"
print("Encrypting file...")
encrypt_file(fn_plainimg, fn_cipherimg)
print("Finished.")
print("Decrypting file...")
decrypt_file(fn_cipherimg, fn_decipherimg)
print("Finished.")

def gen_sbox():
    """
    Generates Rijndael's S-box.
    """
    sbox = [0x63]
    bv = BitVector(intVal=0x63, size=8)
    for i in range(1, 256):
        a = BitVector(intVal=i, size=8)
        b = a.gf_MI(AES_modulus, 8)
        s = bv ^ b ^ (b << 1) ^ (b << 1) ^ (b << 1) ^ (b << 1)
        sbox.append(s.intValue())

    # for i in range(0, 16):
    #     for j in range(0, 16):
    #         print(hex(sbox[i * 16 + j]), end=' ')
    #     print()

    return sbox

def gen_invsbox():
    """
    Generates Rijndael's Inverse S-box.
    """
    inv_sbox = []
    bv = BitVector(intVal=0x5, size=8)
    for i in range(0, 0x100):
        if i == 0x63:
            inv_sbox.append(0x0)
            continue
        s = BitVector(intVal=i, size=8)
        b = bv ^ (s << 1) ^ (s << 2) ^ (s << 3)
        inv_sbox.append(b.gf_MI(AES_modulus, 8).intValue())

    # for i in range(0, 16):
    #     for j in range(0, 16):
    #         print(hex(inv_sbox[i * 16 + j]), end=' ')
    #     print()

    return inv_sbox

def check_sbox(sbox):
    for i in range(0, 256):
        if Sbox[i] != sbox[i]:
            print('Problem found in', hex(i))
            return False
    return True

def check_invsbox(invsbox):
    for i in range(0, 256):
        if InvSbox[i] != invsbox[i]:
            print('Problem found in', hex(i))
            return False
    return True

print("Generating SBox...")
sbox = gen_sbox()
if (check_sbox(sbox)):
    print('Sbox generation successful!\n')
else:
    print('Sbox generation unsuccessful!\n')

print("Generating InvSBox...")
invsbox = gen_invsbox()
if (check_invsbox(invsbox)):
    print('InvSbox generation successful!\n')
else:
    print('InvSbox generation unsuccessful!\n')
